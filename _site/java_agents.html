<!DOCTYPE HTML>
<html>
<head>
  <title>Eve - Agents </title>
  <link rel="shortcut icon" href="img/favicon.ico" >
  <link type="text/css" rel="stylesheet" href="css/style.css"> 
  
  <meta name="title" content="Eve - Agents">   
  <meta name="keywords" content="eve, agent, software agent, software agents, agent platform, scalable, multiplatform, multipurpose, web based, cloud, http, json, json-rpc, opensource, open source" >
  <meta name="description" content="Eve is a multipurpose, web based agent platform. The project aims to develop an open protocol for communication between software agents. Eve is designed as a decentral, scalable system for autonomously acting agents. Eve uses the existing world wide web as platform, and uses existing protocols for data exchange (HTTP) and for messaging (JSON-RPC)." >
  <meta name="author" content="Almende B.V." >

</head>

<body>

<a href="https://github.com/almende/eve" style="position: fixed; top: 0; right: 0; border: 0;" >
  <img 
    src="img/forkme_right_darkblue_121621.png" 
    alt="Fork me on GitHub" >
</a>
  
<div id="container">

<div id="menu">
<div id="menu-inner">

<a href="http://almende.github.com/eve"><img src="img/logo/eve128.png" alt="logo"></a>
<br>

<div class="nav">
<ul>
  <li>
    Eve
    <ul>
      <li><a class="nav" href="index.html">Introduction</a></li>
      <li><a class="nav" href="protocol.html">Protocol</a></li>
    </ul>
  </li>

  <li>
    Java
    <ul>
      <li><a class="nav" href="java_overview.html">Overview</a></li>
      <li><a class="nav" href="java_gettingstarted.html">Getting Started</a></li>
      <li><a class="nav" href="java_libraries.html">Libraries</a></li>
      <li><a class="nav" href="java_hosting.html">Hosting</a></li>
      <li><a class="nav" href="java_agents.html">Agents</a></li>
      <!--<li><a class="nav" href="java_examples.html">Examples</a></li>-->
    </ul>
  </li>

  <li>
    Node.js
    <ul>
      <li><a class="nav" href="nodejs_overview.html">Overview</a></li>
    </ul>    
  </li>
</ul>
</div>

</div>
</div>

<div id="contents">
  <h1 id='agents'>Agents</h1>

<p>An Eve agent is created as a regular Java class. The class must inherit from the base class Agent. Public methods will be made available via <a href='protocol.html'>JSON-RPC</a>. The methods must have named parameters. An agent is <a href='java_hosting.html'>hosted</a> via a servlet. To make a new agent class available via the servlet, the class must be added to the servlet configuration.</p>

<p>The Java code of a basic Eve agent looks as follows:</p>

<pre><code>import com.almende.eve.agent.Agent;
import com.almende.eve.json.annotation.Name;

public class ExampleAgent extends Agent {
    public Double welcome(@Name(&quot;name&quot;) String name) {
        return &quot;Hello &quot; + name + &quot;!&quot;;
    }
    
    @Override
    public String getVersion() {
        return &quot;0.1&quot;;
    }
    
    @Override
    public String getDescription() {
        return &quot;This agent can do this and that for you.&quot;;
    }    
}</code></pre>

<p>Remarks on this example:</p>

<ul>
<li>An Eve agent extends from the base class Agent.</li>

<li>Two methods are required to implement: getVersion and getDescription. Other methods, such as getMethods, getId, getUrl, are inherited from the class Agent.</li>

<li>The Example agent implements a method welcome, which takes one String &#8220;name&#8221; as parameter. Each method can have multiple parameters of any type, and the parameters must be named using the annotation @Name. This is needed because the JSON-RPC 2.0 protocol uses named parameters, and unfortunately it is not possible in Java to retrieve the parameter names automatically via reflection.</li>
</ul>

<h2 id='methods'>Methods</h2>

<p>Eve agents communicate with each other via JSON-RPC 2.0. All public methods of an Eve agent are automatically exposed via JSON-RPC. An agent must implement the following methods:</p>

<ul>
<li><code>getDescription</code> returning a textual description of the agent.</li>

<li><code>getVersion</code> returning the version number of the agent.</li>
</ul>

<p>All agents automatically inherit the following methods from the base class Agent:</p>

<ul>
<li><code>getMethods</code> returns an automatically generated list with all available methods.</li>

<li><code>getType</code> returns the class name of the agent.</li>

<li><code>getUrl</code> returns the full url of the agent.</li>

<li><code>getId</code> returns the id of the agent</li>

<li><code>subscribe</code> to subscribe to an event</li>

<li><code>unsubscribe</code> to unsubscribe from an event</li>
</ul>

<p>The parameters of a method must be named using the <code>@Name</code> annotation. Parameters can be marked as optional using the annotation <code>@Required</code>. Non-required parameters are initialized with value <code>null</code> when not provided. Parameters can be of any type, both primitive types like Double or String, and Java objects such as a Contact or Person class.</p>

<pre><code>public void storePerson (@Name(&quot;person&quot;) Person person, 
        @Name(&quot;confirm&quot;) @Required(false) Boolean confirm ) {
    // ...
}</code></pre>

<h2 id='instances'>Instances</h2>

<p>Eve agents themselves are stateless. Every request, a new instance of the agent is loaded in memory, and destroyed again when done. Variables in the agents class are not persisted. Instead, an agent can store its state using its <a href='#context'>context</a>.</p>

<p>As the agents are stateless, it is possible to have multiple instances of the same agent running simultaneously. The amout of work which can be done by one agent is thus not limited to the limitations of one physical server, but can be scaled endlessly over more instances running on different servers in the cloud. One interesting use for this is parallel processing of computationally intensive tasks.</p>

<h2 id='context'>Context</h2>

<p>Each agent has a context available which can be used to persist the agents state. The Context can be accessed via the method <code>getContext</code>, and offers a simple key/value storage. It is shared amongst all running instances of an agent.</p>

<p>The Context is meant for storing a limited amount of state parameters, and not as complete database solution. For storing large amounts of data, a database natively available to the agents should be used. For example when running on Google App Engine, an agent can use the Google Datastore. When running on Amazon Elastic Cloud, Amazons SimpleDB or DynamoDB can be used.</p>

<p>The Context offers an interface which is independent of the platform where the agent is deployed.</p>

<p>An example of using the context is shown in the following example:</p>

<pre><code>public void setUsername(@Name(&quot;username&quot;) String username) {
    Context context = getContext();
    context.put(&quot;username&quot;, username);
}

public String getUsename() {
    Context context = getContext();
    if (context.has(&quot;username&quot;)) {
        return (String) context.get(&quot;username&quot;);
    }
    else {
        return null;
    }
}</code></pre>

<h2 id='events'>Events</h2>

<p>Agents can subscribe on events from other agent. They will be triggered when the event occurs.</p>

<p>To subscribe AgentX to an event from AgentY, a JSON-RPC call is made to AgentY. The method <code>subscribe</code> is called, with three parameters: the name of the event, a callback url containing the url of AgentX, and a callback method on which AgentX wants to receive the triggered event. In the example below, AgentX subscribes to the event <code>dataChanged</code>, and wants to receive a triggered event on its method <code>onEvent</code>.</p>

<pre><code>public void subscribeToAgent() throws Exception {
    String url = &quot;http://server/agents/agenttype/agentx&quot;;
    String method = &quot;subscribe&quot;;
    ObjectNode params = JOM.createObjectNode();
    params.put(&quot;event&quot;, &quot;dataChanged&quot;);
    params.put(&quot;callbackUrl&quot;, getUrl());
    params.put(&quot;callbackMethod&quot;, &quot;onEvent&quot;);
    send(url, method, params);
}

public void unsubscribeFromAgent() throws Exception {
    String url = &quot;http://server/agents/agenttype/agentx&quot;;
    String method = &quot;unsubscribe&quot;;
    ObjectNode params = JOM.createObjectNode();
    params.put(&quot;event&quot;, &quot;dataChanged&quot;);
    params.put(&quot;callbackUrl&quot;, getUrl());
    params.put(&quot;callbackMethod&quot;, &quot;onEvent&quot;);
    send(url, method, params);
}

public void onEvent(@Name(&quot;agent&quot;) String agent, 
        @Name(&quot;event&quot;) String event, 
        @Required(false) @Name(&quot;params&quot;) ObjectNode params) 
        throws Exception {
    System.out.println(&quot;onEvent &quot; + agent + &quot; &quot; + event + &quot; &quot; + 
            ((params != null) ? params.toString() : &quot;&quot;));
}</code></pre>

<p>To let AgentY trigger the event <code>dataChanged</code>, the method <code>trigger</code> can be used. This will send a JSON-RPC call to all agents that have subscribed to that event.</p>

<pre><code>trigger(&quot;dataChanged&quot;);</code></pre>

<p>An agent can subscribe to a single event using the event name, or subscribe to all events by specifying a star <code>*</code> as event name.</p>

<h2 id='scheduler'>Scheduler</h2>

<p>Unlike some traditional agent platforms, Eve agents are not contiuously running as a thread on some server. An Eve agent must be triggered externally to execute a task. An action can be triggered in different ways:</p>

<ul>
<li>An external agent makes a call.</li>

<li>An event is triggered.</li>

<li>A scheduled task is triggered.</li>
</ul>

<p>The first two ways are events triggered exernally and not by the agent itself. An agent can schedule a task for itself using the built in Scheduler. The scheduler can be used to schedule a single task and repeating tasks.</p>

<p>A task is a delayed JSON-RPC call to the agent itself. Tasks can be created, listed, and canceled. A task can be scheduled in the following way</p>

<pre><code>public String createTask() throws Exception {
    String url = getUrl();
    ObjectNode params = JOM.createObjectNode();
    params.put(&quot;message&quot;, &quot;hello world&quot;);
    JSONRequest request = new JSONRequest(&quot;myTask&quot;, params);
    long delay = 5000; // milliseconds
    
    Scheduler scheduler = getContext().getScheduler();
    String id = scheduler.setTimeout(url, request, delay);
    return id;
}

public void myTask(@Name(&quot;message&quot;) String message) {
    System.out.println(&quot;myTask is executed. Message: &quot; + message);
}</code></pre>

<h2 id='database'>Database</h2>

<p>The Eve libraries do not include interfaces for data storage, besides the context to store an agents state. To connect an agent to a database (such as the Google Datastore), the regular libraries and interfaces for that specific database should be used.</p>
  
  <div class="lastupdate">
  Last updated: 13 April 2012
  </div>
</div>

</div>
</body>
</html>
