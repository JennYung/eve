<!DOCTYPE HTML>
<html>
<head>
  <title>Eve - Introduction </title>
  <link rel="shortcut icon" href="/img/favicon.ico" />
  <link type="text/css" rel="stylesheet" href="css/style.css"> 
  
  <script type="text/javascript" src="js/smoothscroll.js"></script>
</head>

<body>

<a href="https://github.com/almende/eve" style="position: fixed; top: 0; right: 0; border: 0;" >
  <img 
    src="img/forkme_right_darkblue_121621.png" 
    alt="Fork me on GitHub" />
</a>
  
<div id="container">

<div id="menu">
<div id="menu-inner">

<a href="http://almende.github.com/eve"><img src="img/logo/eve128.png" alt="logo"></a>
<br>

<div class="nav">
<ul>
  <li>
    Eve
    <ul>
      <li><a class="nav" href="index.html">Introduction</a></li>
      <li><a class="nav" href="protocol.html">Protocol</a></li>
    </ul>
  </li>

  <li>
    Java
    <ul>
      <li><a class="nav" href="java_overview.html">Overview</a></li>
      <li><a class="nav" href="java_gettingstarted.html">Getting Started</a></li>
      <li><a class="nav" href="java_examples.html">Examples</a></li>
    </ul>
  </li>

  <li>
    Node.js
    <ul>
      <li><a class="nav" href="nodejs_overview.html">Overview</a></li>
    </ul>    
  </li>
</ul>
</div>

</div>
</div>

<div id="contents">
  <h1 id='introduction'>Introduction</h1>

<p>Eve is a multipurpose, web based agent platform. The project aims to develop an open protocol for communication between software agents. Eve is designed as a decentral, scalable system for autonomously acting agents. Eve uses the existing world wide web as platform, and uses existing protocols for data exchange (HTTP) and for messaging (JSON-RPC).</p>

<p>This page introduces the core concepts of Eve:</p>

<ul>
<li><a href='#scalable'>Web-based, decentral, and scalable</a></li>

<li><a href='#protocol'>Simple communciation protocol</a></li>

<li><a href='#multiplatform'>Multiplatform</a></li>

<li><a href='#multipurpose'>Multipurpose</a></li>

<li><a href='#modular'>Modular</a></li>

<li><a href='#opensource'>Open source</a></li>
</ul>

<p><a href='img/eve_overview.png'><img title='Click for a larger view' src='img/eve_overview_small.png' style='margin-top: 30px;' /></a></p>

<h2 id='scalable'>Web-based, decentral, and scalable</h2>

<h3 id='scalable'>Scalable</h3>

<p>Eve uses a web-based communication protocol. This has a various advantages. Each agent has its own unique url on the web, and can be located on any server. This makes the system scalable and allows an unlimited number of agents in the system. Thus, when scaling the system up, there is no complex installation or configuration required to add an extra server to the system. It is enough to make the new server with agents available on the web, and get agents to know the existens of these new agents. More about this in the next section.</p>

<p>Agents have a persisted state. In that case the url of the agent will not only include the server where the agent resides, but also contain a unique identifier to address the correct agent. On the other hand, agents can also be stateless and just have one generic url. This can be the case for agents offering generic web services such as directions information.</p>

<h3 id='shared_services'>Shared services</h3>

<p>One of the strengths of the web-based approach is its scalability. This approach leads to a decentral system, a system without one central coordination point. The question arises how agents get to know each other. There is no central list containing all agents available, which can be used to get in contact with other agents. The answer is shared services. This works quite similar to how people get to know each other: at work, in their street, at sports, when going out, and other occasions where people come together. With the software agents it works in the same way: agents can meet each other via shared services. For example when different agents act in the same calendar, or agents have registred themselves to a locations service where the locations service is capable of returning all agents located in a certain neighborhood.</p>

<p>Shared services are not predefined in Eve, but will be developed depending on the different application domains for which agents are developed.</p>

<p>There is one built-in solution via which it is possible to retrieve all agents residing on one server, namely via the ManagerAgent which is always available. This ManagerAgent is capable of creating, deleting, and listing agents on its own server.</p>

<h3 id='asynchronous'>Asynchronous</h3>

<p>Communication from an agent to another agent can be done in two ways: synchronously or asynchronously. It is strongly recommended to use asynchronous communication, and develop agents in a stateless manner.</p>

<p>When making a regular (sychronous) call from agent A to agent B, agent A will block until it receives a response from agent B, and then move on with its tasks. Now suppose that agent A has to contact a large set of agents and do something with the responses. it is possible that these agents in turn need to retrieve information from other agent before sending a response. In the end, this can lead to a large set of nested requests. This is very error phrone, and for example leads to timeout errors.</p>

<p>The recommened solution therefore is asynchronous communication between agents. This communication similar to how humans interact: when person A requests something from person B <em>&#8220;can you comment on this report for me?&#8221;</em>, person A doesn&#8217;t wait until he gets a response. Instead he moves on with his tasks and, and after a while, he will get a response from person B with the requested comments. Eve provides an asynchronous callback mechanism by which an agent can perform a request, and the requested agent will schedule the request and send the response back as soon as finished via a new callback request.</p>

<h3 id='event_driven'>Event driven</h3>

<p>Because the HTTP protocol is used for communication, the agents are passive by nature. The agents are event driven: they can only react to a request. In order to let agents take the initiative to perform an action, actions need to be scheduled. This can be done either from the outside, on server level, or by the agent itself.</p>

<p>The passiveness of the agents in Eve works quite different from most agent platforms. In more traditional agent platorms, agents run actively as a thread on a computer, and schedule their own actions via a delay. With Eve however, agents are normally in a sleep modus, until they get a request to handle. Actions are scheduled externally.</p>

<p>Depending on the implementation, an agents state can be kept actively in the memory, or can be loaded and persisted with each request. The latter results in a so called &#8220;stateless protocol&#8221;, and results in a highly scalable environment. This is the default approach for the Eve libraries so far. However, when an agent is deployed as a dedicated web service with only one instance, it may not be applicable to store its state and just keep the agent loaded in memory (possibly utilizing caching or other optimizations).</p>

<h2 id='protocol'>Communication protocol</h2>

<p>The communication of the agents is realized via existing protocols: the system utilizes the existing world wide web as communications channel. Messages are sent via regular HTTP POST requests. Each software agent has its own unique network url, and can be contacted by sending a JSON-RPC message to this url via a HTTP POST request.</p>

<p>JSON is a lightweight data-interchange format. The protocol is easily readable and writable for humans, and easily parsable for machines. JSON libraries are available in most programming languages, but even without a JSON library it is easy to read/write JSON data.</p>

<p>The simplicity of the communication protocol enables implementations of Eve in all kind of different development platforms, also for platforms not yet supported with a ready made library.</p>

<h2 id='multiplatform'>Development platforms</h2>

<p>Agents can be built on any development platform (Java, CGI, C, PHP, .NET, NodeJS, &#8230;), they just have to meet the protocol such that they can communicate with other agents over the internet. Eve dictates the communication protocol and the transfer protocol, but does not impose any restrictions on the development platform to be used. In fact, Eve makes it very easy to interconnect systems developed on different programming environments and running on different locations. One can create an agent as a wrapper around existing systems and services, offering existing functionallity via the interface of this agent.</p>

<p>Currently there are two implementations of Eve: one in Java and one in Javascript.</p>

<h3 id='java_implementation'>Java implementation</h3>

<p>The Java implementation of Eve comes with a number of stand alone Java libraries which can be implemented in an existing Java project. The core library contains basic agent functionality and two easy to configure web-servlets to host one or multiple agents. There is one abstract Agent class from which new agent implementations can inherit. There is currently one library available for persistency, which uses the Google DataStore. There are various libraries available with agents, acting on different domains such as calendaring.</p>

<h3 id='javascript_implementation'>Javascript implementation</h3>

<p>The Javascript implementation uses NodeJS to run Javascript on the server side, and supports CouchDB for persistency.</p>

<p>The implementation offers a web service which handles the requests. During a request the web service typically loads an agent by its id (provided in the url), executes the required action, and persists and unloads the agent again. The NodeJS library of Eve provides an abstract Agent class, which can be used as base class from which new types of agents can be inherited and created.</p>

<h2 id='multipurpose'>Multipurpose</h2>

<p>The Eve agent platform can be used for all kind of applications. New types of agents can be built to act on any type of domain. Eve offers the base to built your own agent platform.</p>

<p>A number of possible application scenarios for Eve:</p>

<ul>
<li>
<p><strong>Easily set up an agent platform</strong><br />The basic purpose is of course to set up a (scalable) agent platform, containing your own agents and functionality. Eve aims to make it easy to set up the platform.</p>
</li>

<li>
<p><strong>Large scale simulations</strong><br />Eve can be used to set up a large simulation environment, making use of the scalability and options for parallel and asynchronous processing.</p>
</li>

<li>
<p><strong>Wrapping existing services.</strong><br />Web services can be made available for software agents by creating a simple &#8220;wrapper agent&#8221; for the web services. For example a GoogleDirectionsAgent which just uses the existing web services of Google and makes this information service available for all Eve agents.</p>
</li>

<li>
<p><strong>Linking software systems together</strong><br />Existing software systems can be linked to the world of software agents by creating &#8220;wrapper agents&#8221; for the systems. This way it is possible to link completely separeted software systems together via agents, even when the software systems are developed in different development environments or are deployed on different locations.</p>
</li>

<li>
<p><strong>Abstraction layer</strong><br />Eve can be used as an abstraction to link different services acting on the same domain together. For example one can abstract from different calendaring systems by creating agents having the same interface but linked to a different calendaring system (Gmail, Exchange, iCal, &#8230;).</p>
</li>

<li>
<p>And possibly more&#8230;</p>
</li>
</ul>

<h2 id='modular'>Modular set up</h2>

<p>The sourcecode of Eve has been set up in a modular way. There is one core package, Eve Core, which contains the basic functionallity for webservices, persistency, and base classes used to develop new types of agents. On top of this core, various libraries libraries are built, containing agents acting on different application domains such as calendaring, planning, communication, negotiation, reporting, and information systems.</p>

<h3 id='eve_core'>Eve Core</h3>

<p>Eve Core is the core library of Eve. It contains the basic functionallity for webservices, to set up a scalable agent platform. Furthermore it contains solutions for persistency, and contains base classes used to develop new types of agents.</p>

<h3 id='eve_planning'>Eve Planning</h3>

<p>Eve Planning is a library built on top of Eve, which offers agents acting on the domain of calendaring and planning. These agents can take over all kind of (small) administrative tasks from the user, such as dynamically planning of meetings in a calendar, planning travel time. Examples are:</p>

<ul>
<li>
<p>The calendar of a user is managed by a <em>CalendarAgent</em>. It does not matter to what type of calendar the CalendarAgent itself is linked to: Gmail, Exchange, iCal, &#8230;</p>
</li>

<li>
<p>Appointments in the calendar are managed dynamically by <em>MeetingAgents</em>. They negotiate with each other on a time slot in the calendar of their participant(s), and automatically move appointments when needed.</p>
</li>

<li>
<p><em>TravelAgents</em> automatically plan travel time when consecutive appointments with differing locations are found in the calendar.</p>
</li>
</ul>

<h2 id='opensource'>Open source</h2>

<p>Eve is an open platform, and it is encouraged to help extending the platform by providing new libraries with agents, or create implementations in other programming languages, or improve existing code. One of the key issues for the platform to be successful is that it needs to be accessible, open, and easy to implement for any developer in any development environment.</p>

<p>Offering the software as open source is a logic result of the aims for openness and collaborative development.</p>
  
  <div class="lastupdate">
  Last updated: 15 March 2012
  </div>
</div>

</div>
</body>
</html>
